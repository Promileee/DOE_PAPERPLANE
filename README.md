# 试验设计纸飞机试验自动操作平台

昔日进行试验设计的课程设计时，较大的试验量与投掷的不可量化，造成了试验设计阶段的巨大困难。因此我开发了这个操作平台，用于试验设计的试验操作。
课程报告期间察觉大多数同学亦有搭建一个平台的想法，但是受限于时间精力等因素未能如愿。自动化操作的实现并不困难，但是包含了很多步骤，极为繁琐。
故而我想将此平台分享出来，希望能够为各位顺利完成这门课程做出一点绵薄贡献。这个平台并不完美，如遇不理想之处还需各位海涵。
此外，如果各位对此平台有任何更好的想法，希望各位不要吝啬才华，尽情更新。我们希望这个平台能够一届一届传下去，同时一届一届净化。

## 使用说明

首先我们从如何使用这个程序说起。

### 必要库的安装

首先你需要你个基本的Python环境，可以直接使用部分IDE如`PyCharm`提供的环境管理，也可以使用`Conda`类的环境管理程序。
这点网络上教程很多，此处不再赘述。完成环境的创建后你需要在环境中安装以下库，使用不同环境管理的安装方式不同，下面的代码仅仅作为示例。

```Python
pip install pyautogui opencv-python numpy pillow pandas pysseract
```

此外，`Tesseract`库并不能通过环境管理直接安装，可以查询AI，之后将其根目录作为常量输入程序。

```Python
pytesseract.pytesseract.tesseract_cmd = r'D:\Program Files\tesseract\tesseract.exe'
```

### 坐标的测量与输入

程序中将所有坐标作为常量的形式给定。请注意，不同的电脑、不同的显示器、不同的缩放比、不同的`Flash`打开方式、不同的窗口大小都会导致坐标值的不同。
因此，这个部分的坐标是需要**基于你的电脑去进行测量**。

你可以任意新建一个`Python`文件，在其中输入如下代码并运行。

```Python
import pyautogui
pyautogui.mouseInfo()
```

此时`Pyautogui`便会弹出一个窗口，窗口默认图层置顶，显示着当前的坐标。你可以通过这种方式得到坐标值。
当然，你也可以进行全屏截图，然后在图像处理软件中找寻坐标。

### 进行试验操作

完成坐标的输入后，你应当可以开始试验的操作了。将程序翻至最下面，找到`main`函数。你会发现`main`函数第一行就进行了延时操作，像这样。

```Python
time.sleep(3)
```

这个操作的目的是为了保证你在启动程序后有足够的时间将窗口从IDE切换至游戏界面。如果你的手速比较慢，可以适当调整这个值。
之后你会看到一个奇怪的布尔值`first_start`，这个值是为了确定你现在是第一次打开游戏还是已经运行过游戏在游戏结束的界面，因为这两种情况进入游戏的操作不同。

```Python
first_start = False
```
之后便是参数的设置，即你试验设计的关键。在第一次运行程序时，我会建议你只设置一个或几个值，少量的参数尝试程序是否可以正常运行。

```Python
paper_plane_type = ['A']
weight = [50]
elevator = [50]
plane_winglets = ['ON']
angle = [30]
force = [100]
```

前四个参数显而易见，第五个参数`angle`是投掷的角度与水平的夹角，向上为正，向下为负。第六个参数`force`是投掷的力度，力度越大，拖动的距离就越大。
这里有个需要注意的点是，`force`的取值范围仍然与你的电脑有关，所以后续你可以针对`force`这个参数设置很多个踩点值，可以使用`range`函数来进行这一操作。
之后程序会自动运动并将分数与参数组合保存在一个`excel`表格中。

### 两个重要的注意事项！

第一个问题是程序在**得分识别时偶尔会出错**，这与这个游戏奇怪的数字字体有关，我们已经采用了`Tesserate`库来优化这一现象，但是仍然是可能出错的。
所以我们保留了每次操作后分数的**图片**，在你的项目地址里，你可以**人工再次检查分数**的正误并进行一定的纠正。尽管如此，这还是比你手动做试验的效率高出太多。

第二个问题是你可能会觉得这个程序运行得很慢，这是因为我没能实现检测游戏结束的算法，因此直接使用了简单粗暴的延时，你可以在`score`这个函数的第一行看到它。

```Python
def score():
    time.sleep(13)
    ...
```

这个值对所有的操作都是一样的，这显然会损失很多时间。

## 存在的问题与改进的思路

我们已经尽力让这个程序变得完美，但是很遗憾到目前为止它也仅仅停留在能用的层面，还是有很多问题需要优化。如果你恰好擅长这些问题的解决，我很期待你的帮助。
下面是我们认为明显的缺陷，还有很多是我们没有意识到的。我们对已知的缺陷提出了一些解决的思路，但请你不要局限于此。

**在工程学中没有标准答案，能解决问题的办法都是好办法。**

### 坐标值需要给定

在这个程序的最前面我们便以常量的形式给定了所有用到的坐标值与坐标范围。我们也曾尝试过使用图像识别从而自动获取坐标信息，但是受限于我们的能力，稳定性实在令人堪忧。

你可以尝试从图像识别的角度出发，给出更精确的识别策略，从而自动获取坐标。或者从屏幕相对坐标的换算这个思路出发，给出屏幕分辨率，以及游戏界面的边界坐标，据此推算。
后者虽然仍需测量，但是需要测量的坐标数比起先行方法，已经少了太多。

### 得分识别不稳定

前文有所提及，先行程序对于数字的识别并不尽如人意。但是我们已经有了一点思路。
我们曾尝试过使用解包程序如`JPEXS Free Flash Decompiler`(你可以在GitHub搜索，找到他们的官方仓库进行学习与下载)对游戏进行逆向去探寻游戏计算飞行距离的函数。
虽然这个尝试失败了，但是我们逆向得到了数字的字体。如果我们可以将字体Mark，再在得分识别时对比每个数字与mark后的标准数字，找到差异最小的一个。这也许是个不错的思路。

### 无法判断飞行结束

这个问题前文亦有提及，先行程序没有判定飞行结束的算法，因此使用了“简单暴力”的延时，但是这对程序的运行效率产生了很大的影响。
除了此处，程序中还有多出延时，旨在规避过渡动画未结束时进行下一个操作的问题。如果可以实现使用全屏截屏，对比两张截屏之间有无差异来进行结束判断，也是很厉害的操作！

## 写在最后

本平台虽简陋，却立足于解决实际问题，力求将纸飞机试验的繁复操作自动化、规范化。它的构建过程虽充满挑战，但也展现了工程设计中从需求出发、步步实现的思路，这与试验设计的观点是一脉相承的。

希望它能成为一块坚实的基石，让后来者不必从零开始。也期望你们在使用它时，不止于“使用”，更能以此为起点，思考改进、追求完善。技术不应止步，传承不应断裂。愿此平台在一届届使用者的手中不断进化，真正成为共同努力的结晶。
